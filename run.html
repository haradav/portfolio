<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- ビューポート設定でモバイル表示崩れを防止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>エンドレスランナーゲーム</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #f0f0f0;
    }
    canvas {
      display: block;
      background: #fff;
      border: 1px solid #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // キャンバスサイズを画面いっぱいに設定
    let groundHeight; // 後でcanvas高さに応じて再設定
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundHeight = canvas.height * 0.1;  // 地面の高さは画面の10%
      // ゲーム中でなければプレイヤーの位置も再設定
      if (!gameOver) {
        player.y = canvas.height - groundHeight - player.height;
      }
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    let gameOver = false;

    // プレイヤーの設定（衝突判定用の矩形）
    const player = {
      x: 50,
      y: 0,
      width: 30,
      height: 50,
      velocityY: 0,
      jumpStrength: -15,
      gravity: 0.8
    };
    player.y = canvas.height - groundHeight - player.height;

    // 床のストライプ用変数（床が動いている演出用）
    let groundOffset = 0;
    const stripeSpacing = 40;  // ストライプの間隔
    const stripeWidth = 20;    // ストライプの幅
    const stripeHeight = 5;    // ストライプの高さ

    // 障害物配列
    let obstacles = [];
    let obstacleTimer = 0;
    let obstacleInterval = 1500; // 障害物生成間隔（ミリ秒）

    // ゲームスピード
    const gameSpeed = 5;
    
    // 距離
    let distance = 0;

    // キーボード操作（Enterキー）でジャンプまたはリセット
    document.addEventListener('keydown', function(e) {
      if(e.key === 'Enter') {
        if (!gameOver) {
          // 地面にいる場合のみジャンプ
          if (player.y === canvas.height - groundHeight - player.height) {
            player.velocityY = player.jumpStrength;
          }
        } else {
          resetGame();
        }
      }
    });

    // タップ操作にも対応（スマホ用）
    canvas.addEventListener('touchstart', function(e) {
      if (!gameOver) {
        if (player.y === canvas.height - groundHeight - player.height) {
          player.velocityY = player.jumpStrength;
        }
      } else {
        resetGame();
      }
      e.preventDefault();
    }, {passive: false});

    // 障害物生成関数
    function createObstacle() {
      const height = 30 + Math.random() * 30;
      const width = 20 + Math.random() * 30;
      const obstacle = {
        x: canvas.width,
        y: canvas.height - groundHeight - height,
        width: width,
        height: height
      };
      obstacles.push(obstacle);
    }

    // 矩形同士の衝突判定
    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    // スティックフィギュアの描画
    function drawPerson(ctx, x, y, width, height) {
      // 頭
      const headRadius = 10;
      const centerX = x + width / 2;
      const headCenterY = y + headRadius;
      ctx.beginPath();
      ctx.arc(centerX, headCenterY, headRadius, 0, Math.PI * 2);
      ctx.stroke();

      // 体
      const bodyStartY = headCenterY + headRadius;
      const bodyEndY = y + height - 10;
      ctx.beginPath();
      ctx.moveTo(centerX, bodyStartY);
      ctx.lineTo(centerX, bodyEndY);
      ctx.stroke();

      // 腕
      const armsY = bodyStartY + (bodyEndY - bodyStartY) * 0.3;
      ctx.beginPath();
      ctx.moveTo(centerX, armsY);
      ctx.lineTo(centerX - 15, armsY + 10);
      ctx.moveTo(centerX, armsY);
      ctx.lineTo(centerX + 15, armsY + 10);
      ctx.stroke();

      // 脚
      ctx.beginPath();
      ctx.moveTo(centerX, bodyEndY);
      ctx.lineTo(centerX - 10, y + height);
      ctx.moveTo(centerX, bodyEndY);
      ctx.lineTo(centerX + 10, y + height);
      ctx.stroke();
    }

    // ゲームリセット処理
    function resetGame() {
      gameOver = false;
      obstacles = [];
      player.x = 50;
      player.y = canvas.height - groundHeight - player.height;
      player.velocityY = 0;
      obstacleTimer = 0;
      groundOffset = 0;
      distance = 0;
      lastTime = 0;
      requestAnimationFrame(gameLoop);
    }

    // メインのゲームループ
    let lastTime = 0;
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      
      // キャンバス全体をクリア
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 床の描画
      ctx.fillStyle = '#654321';
      ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
      
      // 床ストライプの描画
      groundOffset = (groundOffset + gameSpeed) % stripeSpacing;
      for (let i = 0; i < canvas.width / stripeSpacing + 1; i++) {
         let stripeX = i * stripeSpacing - groundOffset;
         ctx.fillStyle = '#8B4513';
         ctx.fillRect(stripeX, canvas.height - groundHeight + (groundHeight - stripeHeight) / 2, stripeWidth, stripeHeight);
      }
      
      // プレイヤーの物理処理
      player.velocityY += player.gravity;
      player.y += player.velocityY;
      
      // 地面に衝突したら位置調整
      if (player.y > canvas.height - groundHeight - player.height) {
        player.y = canvas.height - groundHeight - player.height;
        player.velocityY = 0;
      }
      
      // プレイヤー（スティックフィギュア）の描画
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#000';
      drawPerson(ctx, player.x, player.y, player.width, player.height);
      
      // 障害物生成
      obstacleTimer += deltaTime;
      if (obstacleTimer > obstacleInterval) {
        createObstacle();
        obstacleTimer = 0;
      }
      
      // 障害物の更新・描画＆衝突判定
      for (let i = obstacles.length - 1; i >= 0; i--) {
        let obs = obstacles[i];
        obs.x -= gameSpeed;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        
        // 画面外に出た障害物は削除
        if (obs.x + obs.width < 0) {
          obstacles.splice(i, 1);
        }
        
        // 衝突判定
        if (checkCollision(player, obs)) {
          gameOver = true;
        }
      }
      
      // 距離更新
      distance += gameSpeed;
      
      // 距離表示（右寄せ）
      ctx.textAlign = 'right';
      ctx.fillStyle = '#000';
      ctx.font = '24px sans-serif';
      ctx.fillText('距離: ' + Math.floor(distance) + ' m', canvas.width - 10, 30);
      
      // ゲームオーバー時の処理
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#FFF';
        ctx.textAlign = 'center';
        ctx.font = '48px sans-serif';
        ctx.fillText('ゲームオーバー', canvas.width / 2, canvas.height / 2 - 40);
        ctx.font = '24px sans-serif';
        ctx.fillText('最終距離: ' + Math.floor(distance) + ' m', canvas.width / 2, canvas.height / 2);
        ctx.fillText('エンターボタンまたはタップでリセット', canvas.width / 2, canvas.height / 2 + 40);
        return;
      }
      
      requestAnimationFrame(gameLoop);
    }

    // ゲーム開始
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
